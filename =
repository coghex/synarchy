{-# LANGUAGE Strict #-}
module Engine.Graphics.Window.GLFW
  ( -- * Window Management
    createWindow
  , createRawWindow
  , destroyWindow
  , showWindow
  , hideWindow
  , makeContextCurrent
  , getGLFWWindow
    -- * Window State
  , windowShouldClose
  , setWindowShouldClose
  , getWindowSize
  , getFramebufferSize
  , GLFW.setWindowSize
  , GLFW.setWindowPos
  , GLFW.getWindowPos
    -- * Event Handling
  , pollEvents
  , pollRawEvents
  , waitEvents
  , waitEventsTimeout
  , GLFW.postEmptyEvent
    -- * Keyboard and Mouse Input
  , GLFW.setKeyCallback
  , GLFW.setErrorCallback
    -- * Vulkan Integration
  , vulkanSupported
  , getRequiredInstanceExtensions
  , createWindowSurface
  , mainThreadHint
    -- * Initialization
  , initializeGLFW
  , terminateGLFW
    -- * Raw init since tests run in IO
  , GLFW.init
  , GLFW.terminate
  , GLFW.Window (..)
  ) where

import UPrelude
import Control.Exception (IOException, catch, ioError)
import Control.Monad.IO.Class (MonadIO(..))
import qualified Data.ByteString as BS
import qualified Data.Text as T
import Data.IORef (readIORef)
import qualified Graphics.UI.GLFW as GLFW
import Engine.Core.Monad
import Engine.Core.State
import Engine.Core.Resource
import Engine.Core.Log (LogCategory(..), logWarn)
import Engine.Core.Log.Monad (logAndThrowM, logDebugM, logInfoM)
import Engine.Core.Error.Exception (ExceptionType(..), GraphicsError(..)
                                   , InitError(..))
import Engine.Graphics.Base (GraphicsConfig(..))
import Engine.Graphics.Window.Types
import Vulkan.Core10 (Instance(..), AllocationCallbacks)
import Vulkan.Extensions.VK_KHR_surface (SurfaceKHR, destroySurfaceKHR)

-- | Initialize GLFW with error handling
initializeGLFW ∷ EngineM ε σ ()
initializeGLFW = do
  success ← liftIO $ GLFW.init
  case success of
    True  → logDebugM CatGraphics "GLFW initialized"
    False → logAndThrowM CatGraphics (ExInit WindowCreationFailed)
                 "Failed to initialize GLFW"
  -- Set necessary window hints for Vulkan
  liftIO $ do
    GLFW.windowHint $ GLFW.WindowHint'ClientAPI GLFW.ClientAPI'NoAPI
    GLFW.windowHint $ GLFW.WindowHint'Resizable True

-- | Creates a GLFW window with given configuration
createWindow ∷ WindowConfig → EngineM ε σ Window
createWindow config = do
  -- initialize glfw
  allocResource (\_ → do
                  terminateGLFW
                  logDebugM CatGraphics "GLFW terminated")
                initializeGLFW

  -- Set window hints
  liftIO $ GLFW.windowHint $ GLFW.WindowHint'Resizable (wcResizable config)
  --liftIO $ GLFW.windowHint $ GLFW.WindowHint'Visible False
  
  -- Create the window
  allocResource (\w0 → destroyWindow w0) $ do
    mw ← liftIO $ GLFW.createWindow (wcWidth config) (wcHeight config)
                                    (T.unpack $ wcTitle config) Nothing Nothing
    case mw of
      Nothing → logAndThrowM CatGraphics (ExInit WindowCreationFailed) $
                 T.pack $ "Failed to create GLFW window with dimensions: "
                 ⧺ show (wcWidth config) ⧺ "x" ⧺ show (wcHeight config)
      Just win → pure $ Window win
    -- set window size reference
  writeIORef (windowSizeRef env) (GLFW.getWindowSize window)
  writeIORef (framebufferSizeRef env) (GLFW.getFramebufferSize window)
 
--
-- | Creates a GLFW window in an IO context for testing
createRawWindow ∷ WindowConfig → IO (Maybe Window)
createRawWindow config = do

  -- Set window hints
  GLFW.windowHint $ GLFW.WindowHint'Resizable (wcResizable config)
  GLFW.windowHint $ GLFW.WindowHint'ClientAPI GLFW.ClientAPI'NoAPI
  GLFW.windowHint $ GLFW.WindowHint'Visible True
  -- Create the window
  mw ← liftIO $ GLFW.createWindow (wcWidth config) (wcHeight config)
                                  (T.unpack $ wcTitle config) Nothing Nothing
  pure $ case mw of
    Nothing → Nothing
    Just win → Just $ Window win

-- | Clean up GLFW window resources
destroyWindow ∷ Window → EngineM' ε ()
destroyWindow (Window win) = liftIO $ GLFW.destroyWindow win

-- | Safely create window with automatic cleanup
initWindow ∷ WindowConfig → EngineM ε σ Window
initWindow config = allocResource destroyWindow $ createWindow config

-- | Show a window
showWindow ∷ GLFW.Window → EngineM ε σ ()
showWindow win = liftIO $ GLFW.showWindow win

-- | Hide a window
hideWindow ∷ GLFW.Window → EngineM ε σ ()
hideWindow win = liftIO $ GLFW.hideWindow win

-- | Check if a window should close
windowShouldClose ∷ GLFW.Window → EngineM ε σ Bool
windowShouldClose = liftIO ∘ GLFW.windowShouldClose

-- | Set whether a window should close
setWindowShouldClose ∷ GLFW.Window → Bool → EngineM ε σ ()
setWindowShouldClose win = liftIO ∘ GLFW.setWindowShouldClose win

-- | Get the current window size
getWindowSize ∷ GLFW.Window → EngineM ε σ (Int, Int)
getWindowSize = liftIO ∘ GLFW.getWindowSize

-- | Get the current framebuffer size
getFramebufferSize ∷ GLFW.Window → EngineM ε σ (Int, Int)
getFramebufferSize = liftIO ∘ GLFW.getFramebufferSize

-- | Set a window's title
setWindowTitle ∷ GLFW.Window → Text → EngineM ε σ ()
setWindowTitle win title = liftIO $ GLFW.setWindowTitle win ( T.unpack title )

-- | Poll for pending events
pollEvents ∷ EngineM ε σ ()
pollEvents = liftIO GLFW.pollEvents
pollRawEvents ∷ IO ()
pollRawEvents = GLFW.pollEvents

-- | Wait for events
waitEvents ∷ EngineM ε σ ()
waitEvents = liftIO GLFW.waitEvents

-- | Wait for events with timeout
waitEventsTimeout ∷ Double → EngineM ε σ ()
waitEventsTimeout = liftIO ∘ GLFW.waitEventsTimeout

-- | Make a window's context current
makeContextCurrent ∷ Maybe GLFW.Window → EngineM ε σ ()
makeContextCurrent = liftIO ∘ GLFW.makeContextCurrent

-- | Hint that we're on the main thread
mainThreadHint ∷ EngineM ε σ ()
mainThreadHint = do
  logger ← liftIO . readIORef =<< asks loggerRef
  liftIO $ GLFW.setErrorCallback $ Just $ \errCode msg →
    logWarn logger CatGraphics $ T.pack $
      "GLFW error: " ⧺ show errCode ⧺ ": " ⧺ msg

-- | Get required Vulkan instance extensions
getRequiredInstanceExtensions ∷ EngineM ε σ [BS.ByteString]
getRequiredInstanceExtensions = do
  exts ← liftIO GLFW.getRequiredInstanceExtensions
  liftIO $ traverse BS.packCString exts

-- | Create a Vulkan surface for a window
createWindowSurface ∷ Window 
                   → Instance  -- ^ Raw Vulkan instance handle
                   → EngineM ε σ SurfaceKHR  -- ^ Raw Vulkan surface handle
createWindowSurface (Window win) inst = allocResource
  (\surface → do
      logDebugM CatVulkan "Destroying window surface"
      liftIO $ destroySurfaceKHR inst surface Nothing)
  $ do
    surfaceOrError ← liftIO $ alloca $ \surfacePtr → do
      result ← GLFW.createWindowSurface 
        (instanceHandle inst)
        win
        nullPtr
        surfacePtr
      if result == 0  -- VK_SUCCESS
        then Right <$> peek surfacePtr
        else pure $ Left $ "Failed to create window surface, error code: "
                         ⧺ show result

    case surfaceOrError of
      Right surface → pure surface
      Left err → logAndThrowM CatVulkan (ExGraphics VulkanSurfaceLost) $
                   T.pack $ "Failed to create window surface: " ⧺ err

-- | Terminate GLFW
terminateGLFW ∷ EngineM ε σ ()
terminateGLFW = liftIO GLFW.terminate

-- | Get the GLFW window handle
getGLFWWindow ∷ Window → GLFW.Window
getGLFWWindow (Window win) = win

vulkanSupported ∷ EngineM ε σ Bool
vulkanSupported = liftIO GLFW.vulkanSupported
