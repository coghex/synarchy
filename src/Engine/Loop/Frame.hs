{-# LANGUAGE CPP, UnicodeSyntax #-}
module Engine.Loop.Frame
  ( drawFrame
  , updateUniformBufferForFrame
  , submitFrame
  , computeAmbientLight
  ) where

import UPrelude
import Control.Exception (displayException)
import qualified Data.Text as T
import qualified Data.Vector as V
import qualified Data.Map as Map
import Data.IORef (readIORef, atomicModifyIORef', writeIORef)
import Linear (identity)
import Engine.Core.Defaults
import Engine.Core.Log (LogCategory(..))
import Engine.Core.Log.Monad (logInfoM, logWarnM, logAndThrowM)
import Engine.Core.Monad
import Engine.Core.State
import Engine.Core.Error.Exception (ExceptionType(..), GraphicsError(..)
                                   , SystemError(..))
import Engine.Graphics.Base
import Engine.Graphics.Camera
import Engine.Graphics.Config (brightnessToMultiplier)
import Engine.Graphics.Window.Types (Window(..))
import Engine.Graphics.Types (DevQueues(..), SwapchainInfo(..))
import qualified Engine.Graphics.Window.GLFW as GLFW
import Engine.Graphics.Vulkan.Buffer
import Engine.Graphics.Vulkan.Command
import Engine.Graphics.Vulkan.Recreate (recreateSwapchain)
import Engine.Graphics.Vulkan.Types
import Engine.Graphics.Vulkan.Types.Descriptor
import Engine.Input.Types (InputState(..))
import Engine.Loop.Resource (validateDescriptorState, getFrameResources, 
                              getCommandBuffer, getDevice, getSwapchain,
                              getQueues, extractWindow)
import Engine.Scene.Render
import Engine.Scene.Base
import Engine.Scene.Types
import Engine.Scene.Types.Batch
import UI.Render (renderUIPages)
import World.Render (updateWorldTiles)
import World.Grid (worldLayer)
import Vulkan.Core10
import Vulkan.Zero
import Vulkan.CStruct.Extends
import Vulkan.Extensions.VK_KHR_swapchain hiding (acquireNextImageKHRSafe)
import GHC.Stack (HasCallStack)

computeAmbientLight ∷ Float → Float
computeAmbientLight sunAngle =
    let angle = sunAngle * 2.0 * π
        sunHeight = sin angle
    in if sunHeight ≥ 0
       then 0.5 + 0.2 * sunHeight   -- day: 0.5 at horizon, 0.7 at noon
       else 0.15 + 0.35 * (1.0 + sunHeight)  -- night: 0.15 at midnight, 0.5 at horizon

-- | Sun cycle speed: full cycle every 600 seconds
sunCycleSpeed ∷ Double
sunCycleSpeed = 1.0 / 600.0

-- | Draw a single frame
drawFrame ∷ EngineM ε σ ()
drawFrame = do
    state ← gets graphicsState
    
    -- Get window
    window@(Window win) ← case extractWindow state of
        Left err → logAndThrowM CatSystem
          (ExSystem (GLFWError "drawFrame: ")) $ T.pack $
            "No window: " ⧺ displayException err
        Right w → pure w
    
    let frameIdx = currentFrame state
    
    -- Get frame resources and device early
    resources ← getFrameResources state frameIdx
    device ← getDevice state
    
    -- Wait for this frame's previous work to complete
    liftIO $ waitForFences device (V.singleton (frInFlight resources)) True maxBound

    -- Try to acquire image BEFORE resetting fence
    swapchain ← getSwapchain state
    acquireResult ← liftIO $ acquireNextImageKHRSafe device swapchain maxBound
                                 (frImageAvailable resources) zero
    
    case acquireResult of
        Left ERROR_OUT_OF_DATE_KHR → do
            logInfoM CatGraphics "Swapchain out of date on acquire, recreating..."
            recreateSwapchain window
        
        Left SUBOPTIMAL_KHR → do
            logInfoM CatGraphics "Swapchain suboptimal on acquire, recreating..."
            recreateSwapchain window
        
        Left err → logAndThrowM CatGraphics
          (ExGraphics SwapchainError) $ T.pack $
            "Failed to acquire swapchain image: " ⧺ show err
        
        Right imageIndex → do
            
            -- NOW reset fence since we're definitely going to submit
            liftIO $ resetFences device (V.singleton (frInFlight resources))

            -- 1. Collect world tile quads (pre-generated by world thread)
            env ← ask
            worldTileQuads ← liftIO $ readIORef (worldQuadsRef env)
            
            -- Read the LIVE camera for the view matrix.
            -- Previously we used worldCamera from the world thread,
            -- which could be tens of milliseconds stale during chunk
            -- generation. This caused the viewport to jerk because
            -- the view matrix lagged behind the actual camera position
            -- that the main thread was updating every frame.
            liveCamera ← liftIO $ readIORef (cameraRef env)
            
            -- 2. Update scene (populates BatchManager with DrawableObjects)
            updateSceneForRender
            sceneMgr ← gets sceneManager
            
            -- 3. Get scene sprites in world layers as SortableQuads
            sceneQuads ← getWorldSceneQuads
            
            -- 4. Merge world tiles + scene sprites, grouped by layer.
            let allWorldQuads = worldTileQuads <> sceneQuads
                groupedByLayer = Map.map V.fromList $
                    V.foldl' (\acc q →
                        Map.insertWith (++) (sqLayer q) [q] acc)
                        Map.empty allWorldQuads
                perLayerBatches = Map.mapWithKey mergeQuadsToBatch groupedByLayer
                worldBatches = V.fromList $ Map.elems perLayerBatches
                worldLayeredBatches = Map.map
                    (\batch → V.singleton (SpriteItem batch))
                    perLayerBatches
            
            -- 5. Render UI
            (uiBatches, uiLayeredBatches) ← renderUIPages
            
            -- 6. Final merge: world + UI
            let batches = worldBatches <> uiBatches
                layeredBatches = Map.unionsWith (<>) 
                    [worldLayeredBatches, uiLayeredBatches]

            -- Use the LIVE camera for the view/projection matrices
            updateUniformBufferForFrame win frameIdx liveCamera
            
            -- Prepare dynamic vertex buffer
            let totalVertices = V.sum $ V.map (fromIntegral . V.length . rbVertices) batches
            
            dynamicBuffer ← if totalVertices > 0
                then do
                    buffer ← ensureDynamicVertexBuffer totalVertices
                    uploadBatchesToBuffer batches buffer
                else ensureDynamicVertexBuffer 6
            
            -- Validate resources
            state'' ← gets graphicsState
            validateDescriptorState state''
            
            -- Record command buffer
            cmdBuffer ← getCommandBuffer resources
            liftIO $ resetCommandBuffer cmdBuffer zero
            recordSceneCommandBuffer cmdBuffer (fromIntegral imageIndex) 
                                     dynamicBuffer layeredBatches
            
            -- Submit
            queues ← getQueues state''
            submitFrame cmdBuffer resources queues
            
            -- Present - get fresh swapchain from state
            currentState ← gets graphicsState
            currentSwapchain ← getSwapchain currentState
            presentResult ← presentFrameWithResult resources queues currentSwapchain imageIndex
            
            case presentResult of
                Left ERROR_OUT_OF_DATE_KHR → do
                    logInfoM CatGraphics
                      "Swapchain out of date on present, recreating..."
                    recreateSwapchain window
                
                Left SUBOPTIMAL_KHR → do
                    logInfoM CatGraphics
                      "Swapchain suboptimal on present, recreating..."
                    recreateSwapchain window
                
                Left err → logAndThrowM CatGraphics
                  (ExGraphics SwapchainError) $ T.pack $
                    "Failed to present: " ⧺ show err
                
                Right () → pure ()
            
            -- Update frame index
            let nextFrame = (frameIdx + 1) `mod` fromIntegral (gcMaxFrames defaultGraphicsConfig)
            modify $ \s → s { graphicsState = (graphicsState s) {
                currentFrame = nextFrame } }
            
-- | Update uniform buffer for current frame
updateUniformBufferForFrame ∷ GLFW.Window → Word32 → Camera2D → EngineM ε σ ()
updateUniformBufferForFrame win frameIdx camera = do
    state ← gets graphicsState
    case (vulkanDevice state, uniformBuffers state) of
        (Just device, Just buffers) → do
            let (_, memory) = buffers V.! fromIntegral frameIdx
            (fbWidth, fbHeight) ← GLFW.getFramebufferSize win
            (winWidth, winHeight) ← GLFW.getWindowSize win

            env ← ask
            brightness ← liftIO $ readIORef (brightnessRef env)
            pixelSnap ← liftIO $ readIORef (pixelSnapRef env)
            sunAngle ← liftIO $ readIORef (sunAngleRef env)
            
            let ambientLight = computeAmbientLight sunAngle
            let uiCamera = UICamera (fromIntegral fbWidth) (fromIntegral fbHeight)
            let facingFloat = case camFacing camera of
                    FaceSouth → 0.0
                    FaceWest → 1.0
                    FaceNorth → 2.0
                    FaceEast → 3.0
            let uboData = UBO identity (createViewMatrix camera)
                              (createProjectionMatrix camera 
                                  (fromIntegral fbWidth) (fromIntegral fbHeight))
                              (createUIViewMatrix uiCamera)
                              (createUIProjectionMatrix uiCamera)
                              (brightnessToMultiplier brightness)
                              (fromIntegral fbWidth) (fromIntegral fbHeight)
                              (if pixelSnap then 1.0 else 0.0)
                              sunAngle
                              ambientLight
                              facingFloat
            
            liftIO $ writeIORef (windowSizeRef env) (winWidth, winHeight)
            liftIO $ writeIORef (framebufferSizeRef env) (fbWidth, fbHeight)
            
            updateUniformBuffer device memory uboData
        _ → logAndThrowM CatGraphics
          (ExGraphics VulkanDeviceLost) $
            T.pack "No device or uniform buffer"

-- | Submit frame to GPU
submitFrame ∷ CommandBuffer → FrameResources → DevQueues → EngineM ε σ ()
submitFrame cmdBuffer resources queues = do
    let waitStages = V.singleton PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT
        submitInfo = zero 
            { waitSemaphores = V.singleton $ frImageAvailable resources
            , waitDstStageMask = waitStages
            , commandBuffers = V.singleton $ commandBufferHandle cmdBuffer
            , signalSemaphores = V.singleton $ frRenderFinished resources
            }
    liftIO $ queueSubmit (graphicsQueue queues) 
               (V.singleton $ SomeStruct submitInfo) (frInFlight resources)

-- | Present frame and return result for handling
presentFrameWithResult ∷ FrameResources → DevQueues → SwapchainKHR → Word32 
                       → EngineM ε σ (Either Result ())
presentFrameWithResult resources queues swapchain imageIndex = do
    let presentInfo = zero
            { waitSemaphores = V.singleton $ frRenderFinished resources
            , swapchains = V.singleton swapchain
            , imageIndices = V.singleton imageIndex
            }
    presentResult ← liftIO $ queuePresentKHR (presentQueue queues) presentInfo
    case presentResult of
        SUCCESS               → pure $ Right ()
        SUBOPTIMAL_KHR        → pure $ Left SUBOPTIMAL_KHR
        ERROR_OUT_OF_DATE_KHR → pure $ Left ERROR_OUT_OF_DATE_KHR
        err                   → pure $ Left err

-- | Safe wrapper for acquireNextImageKHR
acquireNextImageKHRSafe ∷ Device → SwapchainKHR → Word64 → Semaphore → Fence 
                        → IO (Either Result Word32)
acquireNextImageKHRSafe device swapchain timeout semaphore fence = do
    (result, imageIndex) ← acquireNextImageKHR device swapchain timeout semaphore fence
    case result of
        SUCCESS               → pure $ Right imageIndex
        SUBOPTIMAL_KHR        → pure $ Left SUBOPTIMAL_KHR
        ERROR_OUT_OF_DATE_KHR → pure $ Left ERROR_OUT_OF_DATE_KHR
        err                   → pure $ Left err
