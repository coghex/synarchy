diff --git a/src/Engine/Asset/Manager.hs b/src/Engine/Asset/Manager.hs
index 85ec8c5..2914ff3 100644
--- a/src/Engine/Asset/Manager.hs
+++ b/src/Engine/Asset/Manager.hs
@@ -168,8 +168,6 @@ loadTextureAtlas name path arrayName = do
   texHandle ← liftIO $ generateTextureHandle pool
   loadTextureAtlasWithHandle texHandle name path arrayName
 
--- | Load a texture atlas from file with a specific TextureHandle
--- This is used when the handle was already generated (e.g., from Lua)
 loadTextureAtlasWithHandle ∷ TextureHandle  -- ^ Pre-generated handle
                           → Text            -- ^ Name of the atlas
                           → FilePath        -- ^ Path to the atlas file
@@ -184,56 +182,76 @@ loadTextureAtlasWithHandle texHandle name path arrayName = do
   state ← get
   let pool = assetPool state
       pathKey = T.pack path
-  
-  logDebugM CatAsset $ "Current atlas count: " <> T.pack (show $ Map.size $ apTextureAtlases pool)
-  
   -- check if the texture is already loaded
   case Map.lookup pathKey (apAssetPaths pool) of
     Just existingId → do
-      logDebugSM CatAsset "Texture found in cache"
-        [("asset_id", T.pack $ show existingId)
-        ,("ref_count", T.pack $ show $ taRefCount $ (apTextureAtlases pool) Map.! existingId)]
-      
-      -- Get the existing atlas to find its bindless slot
       let existingAtlas = (apTextureAtlases pool) Map.! existingId
       
-      -- Register the NEW handle in bindless system pointing to the SAME slot
-      case (textureSystem (graphicsState state), taBindlessSlot existingAtlas) of
-        (Just bindless, Just slot) → do
-          logDebugM CatAsset $ "Registering duplicate handle " <> T.pack (show texHandle) 
-                            <> " for existing slot " <> T.pack (show slot)
-          
-          -- Get the existing bindless handle for this slot
-          case taInfo existingAtlas of
-            Just texInfo → do
-              device ← case vulkanDevice (graphicsState state) of
-                Just dev → pure dev
-                Nothing → logAndThrowM CatAsset (ExGraphics VulkanDeviceLost) "No device"
+      logInfoSM CatAsset "CACHE HIT - checking if this affects world texture"
+        [("path", T.pack path)
+        ,("existing_id", T.pack $ show existingId)
+        ,("existing_handle", T.pack $ show $ taTextureHandle existingAtlas)
+        ,("new_handle", T.pack $ show texHandle)
+        ,("has_bindless_slot", T.pack $ show $ isJust $ taBindlessSlot existingAtlas)]
+      
+      -- Register the NEW handle in bindless system pointing to the SAME texture
+      currentState ← gets graphicsState
+      case (textureSystem currentState, taInfo existingAtlas) of
+        (Just bindless, Just texInfo) → do
+          -- Check if this handle is already registered (avoid double registration)
+          case Map.lookup texHandle (btsHandleMap bindless) of
+            Just _ → do
+              logDebugM CatAsset $ "Handle " <> T.pack (show texHandle) 
+                                <> " already registered in bindless system"
+            Nothing → do
+              logDebugM CatAsset $ "Registering duplicate handle " <> T.pack (show texHandle) 
+                                <> " for cached texture"
               
-              -- Register the new TextureHandle pointing to the existing texture
-              (mbHandle, newBindless) ← registerTexture device texHandle 
-                                          (tiView texInfo) (tiSampler texInfo) bindless
-              modify $ \s → s { graphicsState = (graphicsState s) {
-                textureSystem = Just newBindless
-                } }
+              -- Atomically update bindless system without capturing stale state
+              modify $ \s → 
+                case (textureSystem (graphicsState s), taInfo existingAtlas) of
+                  (Just bindless, Just texInfo) →
+                    case Map.lookup (taTextureHandle existingAtlas) (btsHandleMap bindless) of
+                      Just existingBindlessHandle →
+                        let newBindless = bindless { 
+                              btsHandleMap = Map.insert texHandle existingBindlessHandle (btsHandleMap bindless)
+                            }
+                        in s { graphicsState = (graphicsState s) { textureSystem = Just newBindless } }
+                      Nothing → s
+                  _ → s
               
-              logDebugM CatAsset $ "Duplicate handle registered: " <> T.pack (show texHandle)
-            Nothing → pure ()
-        _ → pure ()
+              -- Log AFTER the atomic update
+              currentState ← gets graphicsState
+              case (textureSystem currentState, taBindlessSlot existingAtlas) of
+                (Just bs, Just slot) →
+                  logInfoSM CatAsset "Duplicate handle mapped to existing slot"
+                    [("new_handle", T.pack $ show texHandle)
+                    ,("original_handle", T.pack $ show $ taTextureHandle existingAtlas)
+                    ,("existing_slot", T.pack $ show slot)
+                    ,("map_size", T.pack $ show $ Map.size $ btsHandleMap bs)
+                    ,("path", T.pack path)]
+                _ → pure ()
+        (Nothing, _) → 
+          logWarnM CatAsset $ "No bindless system available for duplicate handle " 
+                           <> T.pack (show texHandle)
+        
+        (_, Nothing) → 
+          logWarnM CatAsset $ "Cached texture has no TextureInfo, cannot register duplicate handle " 
+                           <> T.pack (show texHandle)
       
+      -- Increment ref count
       modify $ \s → s { assetPool = (assetPool s) {
         apTextureAtlases = Map.adjust (\a → a { taRefCount = taRefCount a + 1 })
                                       existingId (apTextureAtlases pool) } }
+      
       return existingId
+    
     Nothing → do
-      -- Generate unique asset ID atomically
-      nextId ← liftIO $ generateAssetId pool
-      
-      logDebugSM CatAsset "Creating new texture asset"
-        [("asset_id", T.pack $ show nextId)
-        ,("path", pathKey)
-        ,("handle", T.pack $ show texHandle)]
+      -- Generate next asset ID
+      nextId ← liftIO $ atomicModifyIORef' (apNextAssetId pool) $ \n →
+        (n + 1, AssetId $ fromIntegral n)
       
+      -- Original loading code continues here...
       pDevice ← case (vulkanPDevice $ graphicsState state) of
         Nothing → logAndThrowM CatAsset (ExGraphics VulkanDeviceLost)
                     "No physical device found"
@@ -273,9 +291,8 @@ loadTextureAtlasWithHandle texHandle name path arrayName = do
             Just bHandle → do
               let slot = tsIndex $ bthSlot bHandle
               logDebugSM CatAsset "Bindless texture slot assigned"
-                [("slot", T.pack $ show slot)]
-              let mapSize = Map.size $ btsHandleMap newBindless
-              logDebugM CatAsset $ "Bindless handleMap now has " <> T.pack (show mapSize) <> " entries"
+                [("slot", T.pack $ show slot)
+                ,("handle", T.pack $ show texHandle)]
               pure $ Just slot
             Nothing → do
               logWarnM CatAsset $
@@ -285,16 +302,6 @@ loadTextureAtlasWithHandle texHandle name path arrayName = do
           logWarnM CatAsset "No bindless system available, using legacy path"
           pure Nothing
     
-      -- Get or create texture array state (legacy path)
-      state' ← get
-    
-      let textureData = TextureData
-            { tdImageView = imageView
-            , tdSampler = sampler
-            , tdMipLevels = mipLevels
-            , tdDescriptorSet = error "Descriptor set not yet created"
-            }
-          
       let atlas = TextureAtlas
             { taId = nextId
             , taName = name
@@ -316,39 +323,25 @@ loadTextureAtlasWithHandle texHandle name path arrayName = do
             , taTextureHandle = texHandle
             }
     
-      logDebugSM CatTexture "Texture loaded and registered"
-        [("name", name)
-        ,("asset_id", T.pack $ show nextId)
+      logInfoSM CatAsset "Texture loaded and registered"
+        [("asset_id", T.pack $ show nextId)
         ,("handle", T.pack $ show texHandle)
-        ,("mip_levels", T.pack $ show mipLevels)
-        ,("bindless_slot", maybe "none" (T.pack . show) bindlessSlot)]
-
-      liftIO $ updateTextureState texHandle (AssetReady nextId []) pool
-      
-      -- Verify it was inserted
-      atlases <- liftIO $ readIORef (apTextureHandles pool)
-      logDebugM CatAsset $ "After insert, handle map has " <> T.pack (show $ Map.size atlases) <> " entries"
+        ,("bindless_slot", maybe "none" (T.pack . show) bindlessSlot)
+        ,("name", name)
+        ,("mip_levels", T.pack $ show mipLevels)]
+     
+      gs ← gets graphicsState
+      let currentBindless = textureSystem gs
+      case currentBindless of
+        Just bs → logInfoM CatAsset $ "bindless map now has " <> T.pack (show $ Map.size $ btsHandleMap bs) <> " entries"
+        Nothing → logWarnM CatAsset "No bindless system after texture load"
     
-      -- Update state with fresh pool reads
-      modify $ \s → 
-        let currentPool = assetPool s
-        in s 
-          { assetPool = currentPool
-              { apTextureAtlases = Map.insert nextId atlas (apTextureAtlases currentPool)
-              , apAssetPaths = Map.insert pathKey nextId (apAssetPaths currentPool)
-              }
-          }
-      -- Atomically update the global IORef
-      env ← ask
-      liftIO $ atomicModifyIORef' (assetPoolRef env) $ \poolRef →
-        let updatedPoolRef = poolRef
-              { apTextureAtlases = Map.insert nextId atlas (apTextureAtlases poolRef)
-              , apAssetPaths = Map.insert pathKey nextId (apAssetPaths poolRef)
-              }
-        in (updatedPoolRef, ())
-      
-      finalPool ← gets assetPool
-      logDebugM CatAsset $ "Atlas inserted, new count: " <> T.pack (show $ Map.size $ apTextureAtlases finalPool)
+      modify $ \s → s 
+        { assetPool = (assetPool s)
+            { apTextureAtlases = Map.insert nextId atlas (apTextureAtlases pool)
+            , apAssetPaths = Map.insert pathKey nextId (apAssetPaths pool)
+            }
+        }
     
       pure nextId
 
